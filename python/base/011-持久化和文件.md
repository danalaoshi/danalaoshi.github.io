---
layout: default
title: 持久化和文件
parent: Python编程
nav_order: 14
---

文件是长久保存信息的一种数据信息集合。

文件常用操作有：
- 打开/关闭: 文件一旦打开，需要关闭操作
- 读写内容: 对文件写入内容或者读取内容
- 查找: 查找文件内某一内容

## 文件的打开

文件打开方式通常两种，分别是：
- open函数
- with语句

### open函数
- open函数负责打开文件，带有很多参数
- 第一个参数： 必须有，文件的路径和名称
- mode：第二个参数， 表明文件用什么方式打开
    - r:以只读方式打开
    - w：写方式打开，会覆盖以前的内容
    - x：创建方式打开，如文件已经存在，报错
    - a：append方式，以追加的方式对文件内容进行写入
    - b： binary方式，二进制方式写入
    - t： 文本方式打开
    - +： 可读写

文件的打开参考一下案例：

    # 打开文件，用写的方式
    # r表示后面字符串内容不需要转义
    # f称之为文件句柄, 以后代表这个文件，用它来进行读写
    f = open(r"test01.txt", 'w')
    # 文件打开后必须关闭
    f.close()
    # 此案例说明，以写方式打开文件，默认是如果没有文件，则创建

### with语句

`with`语句使用的技术是一种成为上下文管理协议的技术(ContextManagementProtocal), 
它可以自动判断文件的作用域，自动关闭不再使用的打开的文件句柄, 这样妈妈再也不用担心你忘了
关闭打开后的文件了。

    # with语句案例
    with open(r"test01.txt", 'r') as f:
        pass
        # 下面语句块开始对文件f进行操作
        # 在本模块中不需要在使用close关闭文件f

## 文件的读取

文件读取分别为：
- readline: 按行读取
- list: 读取成列表
- read： 按字符读取

### readline

`readline`读取一行，知道文件末尾则返回空。

下面案例是一个实际使用的代码段:

    # with案例
    with open(r'test01.txt', 'r') as f:
        # 按行读取内容
        strline = f.readline()
        # 此结构保证能够完整读取文件知道结束
        while strline:
            print(strline)
            strline = f.readline()

输出结果是：

    假若他日相逢
    
    我将何以贺你
    
    以沉默
    
    以眼泪

### list

`list`负责把文件内的所有内容按行填充一个列表，然后返回。


对文件的打开，可以使用列表`list`直接打开，这样自动把文件的每一行当做列表的元素进行填充，得到一个
列表：

    # list能用打开的文件作为参数，把文件内每一行内容作为一个元素
    with open(r'test01.txt', 'r') as f:
        # 以打开的文件f作为参数，创建列表
        l = list(f)
        for line in l:
            print(line)

运行结果如下：

    假若他日相逢
    
    我将何以贺你
    
    以沉默
    
    以眼泪

### read

按字符读取文件内容，参数可以是数字，表示一次读取几个字符，也可以没有，表示读到结尾。

    # read是按字符读取文件内容
    # 允许输入参数决定读取几个字符，如果没有制定，从当前位置读取到结尾
    # 否则，从当前位置读取指定个数字符
    with open(r'test01.txt', 'r') as f:
        strChar = f.read(1)
        print(len(strChar))
        print(strChar)
        
运行结果如下：

    1
    假


### seek

读取指针指的是当前文件读到的地方，如果不指定读取指针，默认是文件的开始的地方。

每次读取，文件都回向后移动相应的长度。 我们也可以通过函数来手动移动文件的读取指针。

`seek`函数的功能是移动文件的读取位置，也叫读取指针。

`seek(offset, whence)`是函数的签名，此处：
- from的取值范围：
    - 0：从文件头开始偏移
    - 1：从文件当前位置开始偏移
    - 2：从文件末尾开始偏移
- 移动的单位是字节(byte)
- 注意一个汉字由若干个字节构成
- 返回文件指针移动后的新的绝地地址(从文件开始出的偏移量)

下面代码是文件指针偏移的案例：

    # seek案例
    # 打开文件后，从第5个字节出开始读取
    # 打开读写指针在0处， 即文件的开头
    with open(r'test01.txt', 'r') as f:
        # seek移动单位是字节
        f.seek(6, 0)
        strChar = f.read()
        print(strChar)
      
文件运行结果如下：

    他日相逢
    我将何以贺你
    以沉默
    以眼泪


关于文件读取的一个小案例：

    # 关于读取文件的练习
    # 打开文件，三个字符一组读出内容，然后显示在屏幕上
    # 每读一次，休息一秒钟

    # 让程序暂停，可以使用time下的sleep函数
    import time

    with open(r'test01.txt', 'r') as f:
        # read参数的单位是字符，可以理解成一个汉字就是一个字符
        strChar = f.read(3)
        while strChar:
            print(strChar)
            # sleep参数单位是秒
            time.sleep(1)
            strChar = f.read(3)
            
运行结果如下，请仔细理解结果为什么会这样？ 解释以下运行结果，为什么不是每行三个字符

    假若他
    日相逢
    
    我将
    何以贺
    你
    以
    沉默
    
    以眼泪

### tell

`seek`用来移动读写指针， `tell`用来显示读写指针的当前位置。 

    # tell函数： 用来显示文件读写指针的当前位置
    with open(r'test01.txt', 'r') as f:
        strChar = f.read(3)
        pos = f.tell()
        
        while strChar:
            print(pos)
            print(strChar)
            
            strChar = f.read(3)
            pos = f.tell()
        
以下结果说明`tell`的返回数字的单位是`byte`, `read`是以字符为单位的。 

    9
    假若他
    18
    日相逢
    25
    
    我将
    34
    何以贺
    41
    你
    以
    48
    沉默
    
    57
    以眼泪

## 文件的写操作

文件的写操作主要把内容以某种形式写入文件。

- `write(str)`: 把字符串写入文件
- `writeline(str)`: 把字符串按行写入文件
- 两者区别是：
    - `write`函数参数只能是字符串
    - `writerline`参数可以是字符串，也可以是字符序列

`write`具体案例参看下面代码：

    # write 案例
    # 1. 向文件追加一句诗
    # a代表追加方式打开
    with open(r'test01.txt', 'a') as f:
        # 注意字符串内含有换行符
        f.write("生活不仅有眼前的苟且， \n 还有远方的枸杞")
### writelines

负责向文件写入多行。

    # 可以直接写入行， 用writelines
    # writelines表示写入很多行，参数可以是list格式
    # a代表追加方式打开
    with open(r'test01.txt', 'a') as f:
        # 注意字符串内含有换行符
        f.writelines("生活不仅有眼前的苟且")
        f.writelines("还有远方的枸杞")
    
`writelines`写入列表的案例如下：

    l = ["I", "love", "wangxiaojing"]
    # a代表追加方式打开
    with open(r'test01.txt', 'w') as f:
        # 注意字符串内含有换行符
        f.writelines(l)

## `rb`和 `r`模式的区别
我们使用处理二进制文件时，需要用如下方法

    binfile=open(filepath,'rb')  # 读二进制文件
    binfile=open(filepath,'wb')  # 写二进制文件
    
那么和binfile=open(filepath,'r')的结果到底有何不同呢？

不同之处有两个地方：
1. 使用`r`的时候如果碰到`0x1A`，就会视为文件结束，这就是`EOF`。使用`rb`则不存在这个问题。
即如果你用二进制写入再用文本读出的话，如果其中存在`0X1A`，就只会读出文件的一部分。使用`rb`的时候会一直读到文件末尾。

2. 对于字符串`x='abc\ndef'`，我们可用`len(x`)得到它的长度为7，`\n`
我们称之为换行符，实际上是`0X0A`。当我们用`w`即文本方式写的时候，在`windows`
平台上会自动将`0X0A`变成两个字符`0X0D`，`0X0A`，即文件长度实际上变成8.。
当用`r`文本方式读取时，又自动的转换成原来的换行符。
如果换成`wb`二进制方式来写的话，则会保持一个字符不变，读取时也是原样读取。
所以如果用文本方式写入，用二进制方式读取的话，就要考虑这多出的一个字节了。`0X0D`又称回车符。
linux下不会变。因为linux只使用`0X0A`来表示换行。

## 持久化-pickle
- 序列化(持久化，落地)：把程序运行中的信息保存在磁盘上的过程叫序列化，也可以俗称落地
- 反序列化：序列号的逆过程
- pickle： python提供的序列化模块
- pickle.dump: `pickle` 模块中执行序列化功能的函数
- pickle.load: `pickle` 模块中执行反序列化功能的模块


序列化的案例参看以下代码, 需要注意的是，序列化打开文件的方式必须时候用二进制方式写文件打开：

    # 序列化案例
    import pickle
    age = 19
    with open(r'test01.txt', 'wb') as f:
        # 把变量age序列化写入到文件f
        pickle.dump(age, f)

反序列化使用`load`，把序列化保存的内容读入程序， 反序列化文件的打开方式需要是二进制的读方式打开：

    # 反序列化案例
    import pickle
    with open(r'test01.txt', 'rb') as f:
        # 从文件f中读入变量age
        age = pickle.load(f)
        print(age)

下面是`pickle`读写复杂变量类型的案例：

    # 序列化案例
    import pickle
    a = [19, 'liudana', "i love wangxiaojing", [185, 76]]
    with open(r'test01.txt', 'wb') as f:
        pickle.dump(a, f)


相应的读案例如下：

    with open(r'test01.txt', 'rb') as f:
        a  = pickle.load(f)
        print(a)

操作结果如下：

    [19, 'liudana', 'i love wangxiaojing', [185, 76]]

## 持久化-shelve

`shelve`也是持久化对象的一个`python`工具。

它的使用方法类似字典，用键值对的方式保存数据，存取方式跟字典也很类似。

使用方式一般是打开关闭文件，然后对打开的文件就可以用类似字典的方式存取。

    # 使用shelve创建文件并使用
    import shelve
    # 打开文件
    # shv相当于一个字典
    shv = shelve.open(r'shv.db')

    shv['one'] = 1
    shv['two'] = 2
    shv['three'] = 3

    shv.close()

通过以上案例发现，`shelve`自动创建的不仅仅是一个`shv.db`文件，还包括其他格式文件:

    ```python
    # shelve读取案例
    shv = shelve.open(r'shv.db')
    try:
        print(shv['one'])
        print(shv['threee'])
    except Exception as e:
        print("烦死了")
    finally:
        shv.close()
        
### shelve特性

- 不支持多个应用并行写入: 为了解决这个问题，`open`的时候可以使用`flag=r`
- `shelve`正常情况下不会等待持久化对象进行任何修改: 解决方法是强制写回,`writeback=True`
  

      # shelve 之只读打开
      import shelve
      shv = shelve.open(r'shv.db', flag='r')
      try:
          k1 = shv['one']
          print(k1)
      finally:
          shv.close()

另一个案例：

    import shelve
    shv = shelve.open(r'shv.db')
    try:
        shv['one'] = {"eins":1, "zwei":2, "drei":3}
    finally:
        shv.close()


    shv = shelve.open(r'shv.db')
    try:
        one = shv['one']
        print(one)
    finally:
        shv.close()
    
`shelve`有时会忘记写回，需要使用强制写回

    shv = shelve.open(r'shv.db')
    try:
        k1 = shv['one']
        print(k1)
        # 此时，一旦shelve关闭，则内容还是存在于内存中，没有写回数据库
        k1["eins"] =100
    finally:
        shv.close()
    
上面代码相应的读取代码如下：
        
    shv = shelve.open(r'shv.db')
    try:
        k1 = shv['one']
        print(k1)
    finally:
        shv.close()

上面代码读取结果如下：

    {'eins': 1, 'zwei': 2, 'drei': 3}
    {'eins': 1, 'zwei': 2, 'drei': 3}

如果改为强制写回，则不会造成丢失的问题：

    # shelve忘记写回，需要使用强制写回
    shv = shelve.open(r'shv.db', writeback=True)
    try:
        k1 = shv['one']
        print(k1)
        # 此时，一旦shelve关闭，则内容还是存在于内存中，没有写回数据库
        k1["eins"] =100
    finally:
        shv.close()
        
相应的读取代码如下：
        
    shv = shelve.open(r'shv.db')
    try:
        k1 = shv['one']
        print(k1)
    finally:
        shv.close()

结果如下：

    {'eins': 1, 'zwei': 2, 'drei': 3}
    {'eins': 100, 'zwei': 2, 'drei': 3}



`shelve` 也可以使用`with`管理上下文环境：

    with shelve.open(r'shv.db', writeback=True) as shv:
        k1 = shv['one']
        print(k1)
        # 此时，一旦shelve关闭，则内容还是存在于内存中，没有写回数据库
        k1["eins"] =1000

    
    
    with shelve.open(r'shv.db') as shv:
        print(shv['one'])

运行结果如下：

    {'eins': 100, 'zwei': 2, 'drei': 3}
    {'eins': 1000, 'zwei': 2, 'drei': 3}

