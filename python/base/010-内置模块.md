
---
layout: default
title: 常用内置模块
parent: Python编程
nav_order: 13
--- 

Python作为一种语言只是一堆符号和规则的集合，但如果想方便做事，我们可能还需要很多工具。

Python把常用的功能进行打包来放入统一的一些文件中，我们使用的时候如果需要，只要导入就可以直接使用，此类模块
我们称为内置模块。

一个模块通常可以包括变量，函数，类等内容，从代码组织的角度上讲，模块是大于类的一个组织形式。

本章对常用的模块进行介绍，具体的模块的编写和复杂的使用情况，我们放入高级高级语法中，对于一些非强编程能力要求的
工种，可以不作为学习内容，比如数据分析岗位，自动化岗位等。

## 模块的导入

要想使用模块首选需要导入，我们使用关键字`import`完成。

模块的导入又可以细分为三种，分别是：

- 模块直接导入

    此类导入直接使用`import module_name` 就可以， 以后我们如果使用模块的内容，此时需要使
    >  假如模块名称直接以数字开头，需要借助importlib帮助, 高级语法中介绍
    
    此类使用的大致代码如下：
    
        import module_name
        module_name.function_name
        module_name.class_name
        
    举个栗子：
    
        import time

        # 使用的时候需要带上模块名称
        t = time.localtime()

        print(t)
- 别名导入
    有时候模块的名称跟我们的名称冲突，或者模块名称太长不便于使用，此时我们可以在导入的时候顺便给模块起一个别名，
    这样在使用的时候可以直接使用模块的别名而不是原来的名称，此时需要用到关键字`as`，形式如 `import 模块 as 别名`。
    
    此类模块使用大致如下：
    
        # 给模块起了一个新的名字，以后就用新名字就可以
        import module_name as newname
        newname.function_name
        newname.class_name
        
    举个栗子：
    
       import time as T

        # 使用的时候需要带上别名
        t = T.localtime()

        print(t) 
   
- 部分导入
    
    有时候我们不需要导入整个模块，只需要导入模块的一部分，此时需要用到`from...import...`模式，大意是从模块中导入
    需要的功能或代码。
    
    此时我们导入的部分功能我们直接使用，使用的时候不需要在前面加上模块的名称作为前缀。
    
    示例代码如下：
    
        from module_name import func_name, class_name
        # 导入的功能直接使用，不需要在前面加模块名称
        func_name()
        class_name.functions()
    
    此形式还有一个特殊用法，即从模块中导入所有内容，此时纯属为了在使用的时候省去模块名称，但不推荐，因为可能造成命名空间污染。
    
       from module_name import *

    举个栗子：
    
        from time import localtime

        # 使用的时候需要带上模块名称
        t = localtime()

        print(t)


## 常用模块-calendar

此模块用来表述跟日历相关的功能，注意是日历，不是时间。



```python
# 使用模块必须先导入
import calendar
```


```python
# calendar：　获取一年的日历字符串
# 参数
# w = 每个日期之间的间隔字符数
# l = 每周所占用的行数
# c = 每个月之间的间隔字符数
cal = calendar.calendar(2017, l=0, c=5)
print(cal)
```
这个打印出来是2017年的完整日历。  
比较占篇幅，我们就不打印了。

```python
# isleap() 检测是否是闰年
# 格式：calendar.isleap(年份)
calendar.isleap(2018)
```

结果如下：

    False




```python
# leapdays() 获取指定年份之间闰年的个数
# 格式:calendar.leapdays(开始年份，结束年份)
# 返回值：整数

calendar.leapdays(1998, 2018)

```
得到的结果是：


    5


下面函数获取某年月的日历的字符串，注意是字符串格式，我们可以通过打印查看：

```python
# month（） 获取某个月的日历字符串
# 格式:calendar.month(年，月)
# 回值：月日历的字符串

calendar.month(2018,3)
```

运行结果如下：

    '     March 2018\nMo Tu We Th Fr Sa Su\n          1  2  3  4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29 30 31\n'




```python
# monthrange（） 获取一个月的周几开始即总天数
# 格式：calendar.monthrange(年,月)
# 回值：元组(周几开始,总天数)
# 注意：周默认 0 -6 表示周一到周天

x = calendar.monthrange(2018, 3)
print(x)
```
打印结果如下, 即2018年3月第一天是周三，共计31天：


    (3, 31)

下面函数以矩阵形式(嵌套列表)返回一个年月的日历，每一行表示一周，如果不是从周一开始，则前面填写`0`：


```python
# monthcalendar() 返回一个月每天的矩阵列表
# 格式：calendar.monthcalendar(年，月)
# 回值：二级列表
# 注意：矩阵中没有天数用0表示

x = calendar.monthcalendar(2018,3)
print(x)
```
运行结果如下:


    [[0, 0, 0, 1, 2, 3, 4],
     [5, 6, 7, 8, 9, 10, 11],
     [12, 13, 14, 15, 16, 17, 18],
     [19, 20, 21, 22, 23, 24, 25],
     [26, 27, 28, 29, 30, 31, 0]]

## 常用模块-time

`time`模块是一个非常常用的模块，我们在介绍这个模块之前先介绍几个常用概念。

- 时间戳

     时间戳是使用数值来表示一个时间的方式，数值可能是整型可能是浮点型，根据不同的语言不太一样。
     1. 时间戳是指从1970年1月1日0时0分0秒到指定时间的秒数(毫秒数)。
     2. 1970年以前的时间或者太遥远的未来使用时间戳可能出现异常。
     3. 32位操作系统能够支持到2038年的某一天
    
- UTC时间

   UTC又称为世界协调时间，以英国的格林尼治天文所在地区的时间作为参考的时间，也叫做世界标准时间。
   > 中国时间是 UTC+8 东八区（地理老师告诉我的）


- DST夏令时 

    夏令时就是在夏天的时候将时间调快一小时，本意是督促大家早睡早起节省蜡烛！ 每天变成25个小时，本质没变还是24小时


- 时间元组:  struct_time

    时间元祖是表示时间的一种方式，每个时间都按顺序表示成一个元祖，仅此而已。
    
    元祖内每个值我们又有一个相应的名称，具体表示请看下表，所以，我们对时间元祖的访问，因为它本身是元祖，所以我们可以
    使用下标访问，又因为每个值有一个名称，我们可以通过属性访问啦：

        （年,月，日，时，分，秒，周几，一年中的第几天,是否是夏令时）

            索引		内容    属性			值
            0		年		tm_year		2015
            1		月		tm_mon		1～12
            2		日		tm_mday		1～31
            3		时		tm_hour		0～23
            4		分		tm_min		0～59
            5		秒		tm_sec		0～61  60表示闰秒  61保留值
            6		周几		tm_wday		0～6
            7		第几天	tm_yday		1～366
            8		夏令时	tm_isdst	0，1，-1（表示夏令时）
            
    > 时间元组只是一个包含时间的内容的普通元组而已，别害怕。

### 简单使用

使用模块之前需要导入，我们以后如果不是特别强调，就默认已经导入。


- 获取夏令时或者时区相关内容

        ##时间模块属性
        # timezone  获取当前时区与UTC时间相差的秒数，在没有夏令时的情况下
        # altzone 获取当前时区与UTC时间相差的秒数，在有夏令时的情况下，与timezone相差3600秒
        # daylight 检测当前是否是夏令时时间状态
        #          0 表示是  其他值 不是
        # timezone表示本地失去跟远点的时差
        # 东边是复数,东八区 -28800
        print(time.altzone)
        print(time.timezone)
        print(time.daylight)

- 获取时间戳

    可以直接获取当前时间距离原点时间的值。

        # 反馈时间戳
        t=time.time()
        print(t)
    
    运行结果是一个浮点数，表示当前时间距离1970年1月1日0时的秒数:

        1521620996.841335

- 获取时间的字符串表达

    这个字符串表达人类可以直接阅读，也是我们常用的表达方式。

        #asctime() 返回元组的正常字符串化之后的时间格式 
        # 格式：time.asctime（时间元组）
        # 返回值:字符串 Tue Jun  6 11:11:00 2017
        tt = time.localtime()
        time.asctime(tt)

    运行结果如下：

        'Wed Mar 21 16:11:51 2018'

- 获取时间元祖

    由时间戳获取时间的元祖表达方式
    
        # localtime() 获取指定时间的时间元组格式
        # 格式：time.localtime()
        # 返回值：时间元组
        # 格式：time.localtime(时间戳)
        # 返回值：时间元组
        t = time.localtime()
        print(t)
    
    运行结果如下：

        time.struct_time(tm_year=2018, tm_mon=3, tm_mday=21, tm_hour=16, tm_min=11, tm_sec=51, tm_wday=2, tm_yday=80, tm_isdst=0)

    这个时间元祖的各个值我们可以单独访问，可以使用元祖的下标也可以使用元祖的属性功能：
    
        print(t.tm_hour) #下午16点
        print(t.tm_year) # 2021年

        print(t[3]) #下午16点

- 获取当前时间字符串

    此函数可以看做获取时间字符串的一个简写
    
        # ctime()  相当于 asctime（localtime(时间戳)）
        # 格式：time.ctime([时间戳])
        # 返回值：字符串 Tue Jun  6 11:11:00 2017
        print(time.ctime())
        
    执行结果如下：

        'Wed Mar 21 16:11:51 2018'

- 从时间元祖获取对应的时间戳 - mktime

            # mktime() 使用时间元组获取对应的时间戳
            # 格式：time.mktime（时间元组）
            # 返回值：浮点数时间戳
            time.mktime(time.localtime())


- 暂停程序执行-sleep

    程序执行到这个函数的时候，会休息一定时间，具体时长由参数指定，单位是秒。

        #sleep（）程序睡眠，程序等待
        # 格式:time.sleep(秒数)
        # 返回值：无
        #  输入浮点数
        
- 时间格式化函数-strftime
    
    `strftime`可以将时间元祖转换成任意时间格式，时间格式采用参数指定的方式。

        格式：time.strftime(格式化字符串[,时间元组])
        返回值：根据格式化字符串得到的时间字符串
        
        格式	含义	备注
        %a	本地（locale）简化星期名称	
        %A	本地完整星期名称	
        %b	本地简化月份名称	
        %B	本地完整月份名称	
        %c	本地相应的日期和时间表示	
        %d	一个月中的第几天（01 - 31）	
        %H	一天中的第几个小时（24 小时制，00 - 23）	
        %I	一天中的第几个小时（12 小时制，01 - 12）	
        %j	一年中的第几天（001 - 366）	
        %m	月份（01 - 12）	
        %M	分钟数（00 - 59）	
        %p	本地 am 或者 pm 的相应符	注1
        %S	秒（01 - 61）	注2
        %U	一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周	注3
        %w	一个星期中的第几天（0 - 6，0 是星期天）	注3
        %W	和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始	
        %x	本地相应日期	
        %X	本地相应时间	
        %y	去掉世纪的年份（00 - 99）	
        %Y	完整的年份	
        %z	用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数）		
        %%	%号本身

    以下是一个具体应用的案例，我得到时间元祖后直接用指定参数的方式来格式化输出：
    
        time.strftime("%Y年%m月%d日", time.localtime())

    输出结果为：

        '2018年03月21日'


## 常用模块-datetime

因为已经有了一个`time`模块，所以又出来一个`datetime`模块，有点莫名其妙，我们尝试对这两个进行区别：
- `time`提供的功能更接近原始系统功能， 在 Python 文档里，`time`是归类在`Generic Operating System Services`中，换句话说， 
它提供的功能是更加接近于操作系统层面的。通读文档可知，`time` 模块是围绕着 `Unix Timestamp` 进行的，模块中比较重要的类是`struct_time`。

- `datetime`可以理解为对`time`的高级封装，包含了几个主要的类，分别是：
    - datetime.MINYEAR 和 datetime.MAXYEAR 模块常量表示datetime接受的范围
    - class datetime.date: 一个理想化的日期, 提供year, month, day属性
    - class datetime.time: 一个理想化的时间, 提供hour, minute, second, microsecond, tzinfo.
    - class datetime.datetime: 日期和时间的组合.提供year, month, day, hour, minute, second, microsecond, tzinfo.
    - class datetime.timedelta: 表达两个date,time和datetime持续时间内的微妙差异.
    - class datetime.tzinfo: 时间对象的抽象基类.
    - datetime.date(y, m, d)

仅仅从字面理解，或许可以看做 `datetime.datetime = datetime.time + datetime.date`


本部分内容都需要先导入才能执行，需要先执行：   
`import datetime`


### datetime.datetime

`datetime.datetime`的类定义如下，从中我们可以看出一些信息：
    
        class datetime.datetime(year, month, day[, hour
                    [, minute
                    [, second
                    [, microsecond
                    [, tzinfo]]]]])
          # The year, month and day arguments are required.
          MINYEAR <= year <= MAXYEAR
          1 <= month <= 12
          1 <= day <= n
          0 <= hour < 24
          0 <= minute < 60
          0 <= second < 60
          0 <= microsecond < 10**6
      
`datetime.datetime` 类方法大致如下，我们以列表方式列出：

-    datetime.today(): 返回当前本地datetime. 这个等同于datetime.fromtimestamp(time.time()).
-    datetime.now([tz]): 返回当前本地日期和时间, 如果可选参数tz为None或没有详细说明,这个方法会像today().
-    datetime.utcnow(): 返回当前的UTC日期和时间, 如果tzinfo=None ,那么与now()类似.
-    datetime.fromtimestamp(timestamp[, tz]): 根据时间戳返回本地的日期和时间.tz指定时区.
-    datetime.utcfromtimestamp(timestamp): 根据时间戳返回 UTC datetime.
-    datetime.fromordinal(ordinal): 根据Gregorian ordinal 返回datetime.
-    datetime.combine(date, time): 根据date和time返回一个新的datetime.
-    datetime.strptime(date_string, format): 根据date_string和format返回一个datetime.

常用的实例方法如下：

-    datetime.date(): 返回相同年月日的date对象.
-    datetime.time(): 返回相同时分秒微秒的time对象.
-    datetime.replace(kw): kw in [year, month, day, hour, minute, second, microsecond, tzinfo], 与date类似.

类属性如下：

-    datetime.min: datetime(MINYEAR, 1, 1).
-    datetime.max: datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999).

实例属性如下，需要说明的是，这个实例属性一般是只读属性：

-    datetime.year: 1 至 9999
-    datetime.month: 1 至 12
-    datetime.day: 1 至 n
-    datetime.hour: In range(24). 0 至 23
-    datetime.minute: In range(60).
-    datetime.second: In range(60).
-    datetime.microsecond: In range(1000000).

代码示例如下：

    from datetime import datetime as dt, timedelta
    print(dt.now())

打印结果如下:

    2018-03-21 17:47:05.706704

### datetime.date类

 一个date对象代表理想化的日期。

常见类方法如下：

-    date.today()
-    date.fromtimestamp(timestamp)

常用实例属性:

-    date.min: 返回 date(MINYEAR, 1, 1).
-    date.max: 返回 date(MAXYEAR, 12, 31).
-    date.year: 返回 年, MINYEAR和MAXYEAR之间
-    date.month: 返回 月, 1到12月之间
-    date.day: 返回 1到 n 之间.
 
实例方法列表：
-    date.replace(year, month, day):返回一个相同值的data对象, 除了这些参数给关键字指定新的值.
-    date.timetuple(): 返回一个time.struct_time对象.
-    date.toordinal(): 返回一个Gregoian Calendar对象.
-    date.weekday(): 返回day of the week. 星期一为0,星期日为6.
-    date.isoweekday(): 返回day of the week. 星期一为1,星期日为7.
-    date.isocalendar(): 返回一个三元组, (ISO year, ISO week number, ISO weekday).
-    date.isoformat(): 返回 一个'YYYY-MM-DD'的字符串格式.
-    date.ctime(): 返回一个字符串日期, d.ctime() 等同于 time.ctime(time.mktime(d.timetuple())).
-    date.strftime(format): 返回一个字符串日期, 格式自定义.

### datetime.time类
代表本地一天内时间。

类定义格式如下, 定义的时候需指定时间表示的具体值：

    class datetime.time([hour
          [, minute
          [, second 
          [, microsecond
          [, tzinfo]]]]])
      # All arguments are optional.
      # 所有参数都是可选的.
      0 <= hour < 24
      0 <= minute < 60
      0 <= second < 60
      0 <= microsesond < 10**6

### datetime.timedelta
- 该函数表示两个时间的间隔
- 参数可选、默认值都为0：
    
        datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

下面代码要表示一个小时之后的时间：

        from datetime import datetime,timedelta

        time1 = datetime.now()

        print(time1)
        print (time1.strftime("%y-%m-%d %H:%M:%S"))
        print ((time1+timedelta(hours =1)).strftime("%y-%m-%d %H:%M:%S"))


## timeit

一般这个模块用当自作代码执行时间测量工具，即用来测试代码的运行时间。

`timeit.timeit`用来具体测量代码执行时间。

    import timeit

    # 定义需要执行的代码片段
    c = """
    sum = []
    for i in range(1000):
        sum.append(i)
    """

    t1 = timeit.timeit(stmt="[i for i in range(1000)]", number=100000) 
    t2 = timeit.timeit(stmt=c, number=100000)

    print(t1)
    print(t2)

执行结果如下，代表两个代码片段分别执行的具体时间：

    2.830661780000014
    6.494453950999969


`timeit.timeit`中放入的代码片段还可以以函数形式存在：


    def doIt():
        num = 3
        for i in range(num):
            print("Repeat for {0}".format(i))
            
    # 注意放入的形式，不需要给参数和小括号
    t = timeit.timeit(stmt=doIt, number=10)
    print(t)


如果函数带有参数，我们需要用到另一个参数`setup`用来定义上下文环境， 调用带参数的函数案例

    #定义代码的片段
    s = ''' 

    def doIt(num ):
     
        for i in range(num):
            print("Repeat for {0}".format(i))
    '''
    # 注意代码写法
    t = timeit.timeit("doIt(num)", setup=s + "num=3", number=10)
    print(t)


## 系统相关操作模块

在`Python`中，与系统相关的操作主要存在于三个大的模块当中:
1. `os`:  操作系统目录相关等操作
2. `os.path`:   系统路径相关的操作模块
3. `shutil`:  高级文件操作模块, 包括目录树的操作，文件的复制，删除，移动....

### OS模块

本模块主要操作目录，常用的操作如下：

- getcwd() 获取当前的工作目录

        格式：os.getcwd()
        返回值：当前工作目录的字符串

        当前工作目录就是程序在进行文件相关操作，默认查找文件的目录

- chdir() 改变当前的工作目录

        格式：os.chdir（路径）
        返回值：无

- listdir() 获取一个目录中所有子目录和文件的名称列表

        格式:os.listdir(路径)
        返回值：所有子目录和文件名称的列表

- mkdir() 创建一个目录

        格式：os.mkdir（路径）
        返回值:无

- makedirs（） 递归创建文件夹

	   格式：os.makedirs(递归路径)
	   返回值：无
	
        递归路径：多个文件夹层层包含的路径就是递归路径 例如 a/b/c...

- rmdir() 移除一个空目录

        格式：os.rmdir(路径)
        返回值：无

        注意：只能删除没有任何内容的空目录，删除之后内容不会进入回收站

- removedirs（） 递归删除目录

        格式:os.removedirs(递归目录)
        返回值：无

        注意：只能删除没有任何内容的空目录，删除之后内容不会进入回收站

- rename() 修改文件夹名称

        格式：os.rename(原文件夹路径，新文件夹路径)
        返回值：无

- stat() 获取文件相关信息

        格式：os.stat(路径)
        返回值：文件信息组成的元组

- system() 运行系统shell命令

        格式：os.system(系统命令)
        返回值：打开一个shell或者终端界面
        一般使用subprocess代替

- getenv() 获取指定的系统环境变量值

        格式：os.getenv('环境变量名')
        返回值：指定环境变量名对应的值

- putenv() 设置或者添加系统环境变量值
    
        格式：os.putenv(环境变量名,环境变量值)
        返回值：无

- exit() 推出当前程序
	
        格式：exit()
        返回值:无


除上面函数外，其他常用的属性还包括：

- os.curdir:  获取当前路径
- os.pardir: 获取当前文件夹的上一级文件夹路径
- os.sep: 获取当前系统的路径分隔符
- os.linesep: 获取当前系统的换行符号
    因为win系统和linux系统换行符不一致，有时候我们需要知道当前的换行符是什么：
    - window: `\r\n`  
    - Linux: `\n`

- os.name 获取当前系统的名称
    - window: nt  
    - mac: posix  
    - linux: 暂无


### `os.path`模块

本模块主要处理跟路径相关的内容。

常用的功能函数如下：

- abspath() 将路径转化为绝对路径

        格式:os.path.abspath('路径')
        返回值：路径的绝对路径形式

- basename() 获取路径中的文件名部分

        格式:os.path.basename(路径)
        返回值：文件名字符串

- dirname() 获取路径中的文件夹部分

        格式:os.path.dirname(路径)
        返回值：文件夹部分字符串

- join() 将多个路径拼合成一个路径

        格式：os.path.join(路径1，路径2....)
        返回值：组合之后的新路径字符串

- split() 将路径切割为文件夹部分和当前文件部分

        格式:os.path.split（路径）
        返回值：路径和文件名组成的元组

- splitext() 将文件名切割成名称和后缀2部分

        格式：os.path.splitext(文件名)
        返回值：名称和后缀组成的元组

- getsize() 获取文件的大小

        格式:os.path.getsize(文件路径)
        返回值：文件的字节大小

- getctime()  文件创建时间  createtime

        格式：os.path.getctime()
        返回值：时间戳 浮点数

- getmtime()  文件修改时间  modifytime

        格式：os.path.getmtime()
        返回值：时间戳 浮点数

- getatime()  文件访问时间  activetime
	
        格式：os.path.getatime()
        返回值：时间戳 浮点数

- isfile（） 检测是否是文件

        格式：os.path.isfile（路径）
        返回值：布尔值

- isdir（） 检测是否是目录

        格式：os.path.isdir(路径)
        返回值：布尔值

- exists() 检测文件或者目录是否存在

        格式：os.path.exists(路径)
        返回值:布尔值

- isabs() 检测一个路径是否是绝对路径

        格式：os.path.isabs（路径）
        返回值：布尔值

- islink() 检测是否是一个链接

        格式：os.path.islink()
        返回值：布尔值
	
- samefile（） 检测两个路径是否指向同一个文件

        格式：os.path.samefile(路径1,路径2)
        返回值：布尔值

### `shutil`模块

本模块主要负责文件操作相关内容，包括文件拷贝，压缩等。

文件操作类常见操作函数如下：

- copy() 复制文件

        格式：shutil.copy(来源路径，目标路径)
        返回值：返回目标路径

- copy2() 复制文件，保留元数据（文件信息）

        格式：shutil.copy2(来源路径，目标路径)
        返回值：返回目标路径

        注意：copy和copy2的唯一区别在于copy2复制文件时尽量保留元数据


- copyfileobj() 将一个文件中的内容复制到另外一个文件当中

        格式：shutil.copyfileobj(open('源路径','r'),open('目标路径','w'))

        返回值：无

- copyfile()将一个文件中的内容复制到另外一个文件当中

        格式：shutil.copyfile（'源路径','目标路径')

        返回值：无

        注意：如果源路径和目标路径相同，会报错误！

- copytree（） 直接复制整个目录树中的所有内容

        格式：shutil.copytree（源文件夹，目标文件夹）
        返回值：返回目标路径

- copymode()  复制权限  仅供参考

- copystat() 复制状态   仅供参考

- rmtree() 删除整个目录树，即使非空目录也可以删除

        格式：shutil.rmtree(路径)
        返回值：无

- move() 移动文件/文件夹

        格式：shutil.move(源路径，目标路径)
        返回值：目标路径！

- which() 获取可执行程序的位置

        格式：shutil.which('命令字符串')
        返回值:命令程序位置的路径字符串

- disk_usage() 获取磁盘使用情况

        格式：shutil.usage('盘符')
        返回值：元组（总计,使用，剩余）
 
除了相关文件拷贝等内容，`shutil`还可以对文件压缩归档等， 常见操作如:
- 归档：将多个文件或者文件夹合并到一个文件当中, 减少文件数目，方便发送邮件等操作
- 压缩：使用算法将多个文件或者文件夹无损或者有损的合并到同一个文件当中, 减少磁盘占用空间，也方便发送邮件等操作。

此类操作主要时候用函数如：

- make_archive() 归档操作

        格式:shutil.make_archive('归档之后的目录和文件名','后缀','需要归档的文件夹')

        返回值：归档之后的地址

- unpack_archive() 解包操作

        格式：shutil.unpack_archive('归档文件地址','解包之后的地址')
        返回值：解包之后的地址

- get_archive_formats() 获取系统已注册的归档格式和信息

        格式：shutil.archive_formats()
        返回值：列表

- get_unpack_foramts() 获取系统已经注册的解包格式和信息
        
        格式：shutil.unpack_formats()
        返回值：列表


## zip

`zip`模块主要负责压缩文件和解压缩操作。

- zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])

        创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径或类文件对象(file-like object)；参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档，’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。

- ZipFile.getinfo(name):
	
        获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。将在下面 具体介绍该对象。

- ZipFile.infolist()

        获取zip文档内所有文件的信息，返回一个zipfile.ZipInfo的列表。

- ZipFile.namelist()

        获取zip文档内所有文件的名称列表。

- ZipFile.extract(member[, path[, pwd]])

        将zip文档内的指定文件解压到当前目录。参数member指定要解压的文件名称或对应的ZipInfo对象；参数path指定了解析文件保存的文件夹；参数pwd为解压密码。下面一个例子将保存在程序根目录下的txt.zip内的所有文件解压到D:/Work目录：
        
- ZipFile.extractall([path[, members[, pwd]]])

        解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。

- ZipFile.printdir()

        将zip文档内的信息打印到控制台上。

- ZipFile.setpassword(pwd)

        设置zip文档的密码。

- ZipFile.read(name[, pwd])

        获取zip文档内指定文件的二进制数据。下面的例子演示了read()的使用，zip文档内包括一个txt.txt的文本文件，使用read()方法读取其二进制数据，然后保存到D:/txt.txt。

- ZipFile.write(filename[, arcname[, compress_type]])
	
        将指定文件添加到zip文档中。filename为文件路径，arcname为添加到zip文档之后保存的名称, 参数compress_type表示压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。下面的例子演示了如何创建一个zip文档，并将文件D:/test.doc添加到压缩文档中。

- ZipFile.writestr(zinfo_or_arcname, bytes)

        writestr()支持将二进制数据直接写入到压缩文档。

- 属性
    - ZipInfo.filename： 获取文件名称。
	- ZipInfo.date_time： 获取文件最后修改时间。返回一个包含6个元素的元组：(年, 月, 日, 时, 分, 秒)
	- ZipInfo.compress_type： 压缩类型。
	- ZipInfo.comment： 文档说明。
	- ZipInfo.extr： 扩展项数据。
	- ZipInfo.create_system： 获取创建该zip文档的系统。
	- ZipInfo.create_version： 获取 创建zip文档的PKZIP版本。
	- ZipInfo.extract_version： 获取 解压zip文档所需的PKZIP版本。
	- ZipInfo.reserved： 预留字段，当前实现总是返回0。
	- ZipInfo.flag_bits： zip标志位。
	- ZipInfo.volume： 文件头的卷标。
	- ZipInfo.internal_attr： 内部属性。
	- ZipInfo.external_attr： 外部属性。
	- ZipInfo.header_offset： 文件头偏移位。
	- ZipInfo.CRC： 未压缩文件的CRC-32。
	- ZipInfo.compress_size： 获取压缩后的大小。
	- ZipInfo.file_size： 获取未压缩的文件大小。

`zip`模块具体使用参看下面代码：

    import zipfile

    # 生成一个zip的实例 
    zf = zipfile.ZipFile("ws.zip")

    # 压缩保内文件列表
    zf.namelist()

    # 获取qq001.txt的信息
    zf.getinfo("ws/qq001.txt")

    # 解压缩
    zf.extract("ws/qq001.txt", "ws2")

下面是另一个解压缩文件的例子：

    import zipfile, os

    #  利用压缩文件创建zipFile实例
    zipFile = zipfile.ZipFile(os.path.join(os.getcwd(), 'ws.zip'))
    # 对所有压缩的文件解压缩
    for file in zipFile.namelist():
        zipFile.extract(file, r'ws2')
    zipFile.close() #文件打开要关闭 

 

## 数学相关函数 
- 数学相关函数大部分都在math模块当中，所以使用时要先导入math模块
- import math

## random

本模块主要负责随机产生数字或相关随机选取等内容。

- random() 获取0-1之间的随机小数

        格式：random.random()
        返回值：随机0-1之间的小数

- choice() 随机返回序列中的某个值

        格式：random.choice(序列)
        返回值：序列中的某个值
        
- choices(..., k=1) 随机返回序列中的某个值

        格式：random.choices(序列, k=1)
        返回值：序列中随机选取k个元素组成列表返回

- shuffle() 随机打乱列表

        格式：random.shuffle(列表)
        返回值：打乱顺序之后的列表，列表原地排列

- randint（） 返回指定范围内的随机数

        格式：random.randint(开始值,结束值)
        返回值:随机返回开始结束值直接的整数，包括开始结束值

- randrange() 随机返回指定范围内的指定间隔的数值

        格式：random.randrange([开始值,]结束值[,间隔值])
        返回值： 随机返回指定范围内的指定间隔的数值
 

讲了这么多，举个栗子吧：

    import random

    rl = [r*10 for r in range(10)] 
        
        
    print(random.choice(rl))
    print(rl)
    print(random.shuffle(rl))
    print(rl)

上面代码运行结果如下：

    70
    [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
    None
    [20, 30, 60, 50, 0, 90, 80, 10, 40, 70]

