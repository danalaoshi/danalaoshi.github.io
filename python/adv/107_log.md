# 日志(logging)

##  日志相关概念
- 日志: 记录系统运行状态的文件或者记录系统
- 不同的日志使用者有
    - 用户
    - 开发
    - 运维
- 严重性级别(Level): 日志根据用途分成不同的等级, 系统默认分类为
    - DEBUG
    - INFO
    - NOTICE
    - WARNING
    - ERROR
    - CRITICAL
    - ALERT
    - EMERGENCY
    
- 作用:
    - 调试
    - 了解软件运行情况
    - 时候分析定位问题
- 日志信息:
    - time
    - lcoation
    - level
    - content 
- 成熟第三方
    - log4j
    - log4php
    - python: logging, loguru
    
## `logging`模块
- 级别
    - 可以自定义
    - DEBUG
    - INFO
    - WARNING
    - ERROR
    - CRITICAL
- 级别逐渐增加
- 只需要指定一个日志记录的最低级别就好,高级别的自动记录
- 使用方式:
    - 直接使用logging(封装了其他组件)
    - 使用Logging四大组件
    
###  `logging`模块级别日志
- `logging`级别使用以下几个函数
        
```python
    logging.debug(msg, *args, **kwargs) 	创建一条严重级别为DEBUG的日志记录
    logging.info(msg, *args, **kwargs) 	创建一条严重级别为INFO的日志记录
    logging.warning(msg, *args, **kwargs) 	创建一条严重级别为WARNING的日志记录
    logging.error(msg, *args, **kwargs) 	创建一条严重级别为ERROR的日志记录
    logging.critical(msg, *args, **kwargs) 	创建一条严重级别为CRITICAL的日志记录
    logging.log(level, *args, **kwargs) 	创建一条严重级别为level的日志记录
    logging.basicConfig(**kwargs) 	对root logger进行一次性配置

```


- `logging.basicConfig(**kwargs)`函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数
    - 只第一次调用起作用
    - 不配置使用默认值
        - 输出: sys.stderr
        - 级别: WARNING
        - 格式: lever:log name:content
    

```python

import logging

LOG_FORMAT = "%(asctime)s == %(levelname)s ++ %(message)s"
logging.basicConfig(filename="mylog.log", level=logging.CRITICAL, format=LOG_FORMAT)
#logging.basicConfig(level=logging.DEBUG)

logging.debug("This is a debug log.")
logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")


# 另外一种写法
#logging.log(logging.DEBUG, "This is a debug log.")
#logging.log(logging.INFO, "This is a info log.")
#logging.log(logging.WARNING, "This is a warning log.")
#logging.log(logging.ERROR, "This is a error log.")
#logging.log(logging.CRITICAL, "This is a critical log.")
```


### `format`参数

在设置函数中使用到了信息格式内容, 我们在使用格式内容的时候下面参数可以直接使用:
    
- `asctime`: `%(asctime)s` -	日志事件发生的时间--人类可读时间，如：2003-07-08 16:49:45,896
- `created`: `%(created)f` -	日志事件发生的时间--时间戳，就是当时调用time.time()函数返回的值
- `relativeCreated`: `%(relativeCreated)d` -	日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的）
- `msecs`: 	`%(msecs)d` - 	日志事件发生事件的毫秒部分
- `levelname`: 	`%(levelname)s` - 	该日志记录的文字形式的日志级别（'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'）
- `levelno`: 	`%(levelno)s` - 	该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）
- `name`: 	`%(name)s` - 	所使用的日志器名称，默认是'root'，因为默认使用的是 rootLogger
- `message`: 	`%(message)s` - 	日志记录的文本内容，通过 msg % args计算得到的
- `pathname`: `	%(pathname)s` - 	调用日志记录函数的源码文件的全路径
- `filename`: 	`%(filename)s` - 	pathname的文件名部分，包含文件后缀
- `module`: 	`%(module)s` - 	filename的名称部分，不包含后缀
- `lineno`: 	`%(lineno)d` - 	调用日志记录函数的源代码所在的行号
- `funcName`: 	`%(funcName)s` - 	调用日志记录函数的函数名
- `process`: 	`%(process)d` - 	进程ID
- `processName`: 	`%(processName)s` - 	进程名称，Python 3.1新增
- `thread`: 	`%(thread)d` -	线程ID
- `threadName`: `%(thread)s` -	线程名称 

### 日志函数(日志器)
- 日志器有层级的概念,默认是RootLogger,以单例模式运行(后面会详细介绍)
- 对于msg可以使用format格式, logging.debug("%s is %d years old", 'dana', 10)
- **kwargs参数的含义
    - exc_info： 其值为布尔值，如果该参数的值设置为True，则会将异常异常信息添加到日志消息中。如果没有异常信息则添加None到日志信息中。
    - stack_info： 其值也为布尔值，默认值为False。如果该参数的值设置为True，栈信息将会被添加到日志信息中。
    - extra： 这是一个字典（dict）参数，它可以用来自定义消息格式中所包含的字段，但是它的key不能与logging模块定义的字段冲突。
    
```python
import logging

LOG_FORMAT = "%(asctime)s == %(levelname)s ++ %(message)s"
logging.basicConfig(filename="mylog.log", level=logging.CRITICAL, format=LOG_FORMAT)
#logging.basicConfig(level=logging.DEBUG)

logging.debug("This is a debug log.")
logging.info("This is a info log.")
logging.warning("This is a warning log.")
logging.error("This is a error log.")
logging.critical("This is a critical log.")


l = [1,2,4]
try:

    print(l[1])
    print(l[4])
except Exception as e:
    logging.info("ERROR: %s", str(e), exc_info=True, stack_info=True)
    logging.critical("ERROR: %s", str(e), exc_info=True, stack_info=True)

```

### `logging`模块日志处理流程

`logging`日志系统有四大组件, 即模块由四个模块来处理日志
- 日志器	(Logger): 	提供了应用程序可一致使用的接口
- 处理器	(Handler): 	将`Logger`创建的日志记录发送到合适的目的输出
- 过滤器	(Filter): 	提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录
- 格式器	(Formatter): 	决定日志记录的最终输出格式

四大组件参考下面案例:
- 比如刘大拿老师就是一个日志器, 因为我只负责讲课, 从头到尾讲课就行,不考虑受众是谁
- 我的学生就是处理器,因为他们听课的目的不一样, 有的是自己工作, 有的是某些机构的老师, 转述给学生, 有的是家长, 教自己的小孩子学python
- 我的学生需要加一个过滤器, 因为我的学生转述python的目标不一致, 可能有些内容就不需要了, 比如家长教小孩子, 复杂内容就丢弃了, 有的
  学生听课带有强烈目的性,比如用python做爬虫, 那么后台的课程他就不需要了, 过滤了
- 我的学生在使用python的时候可能还需要一个格式器, 我给学生讲课的时候因为学生是成人, 
所以语言系统用的是成人语言系统,但如果在转述给小孩子, 则需要转换成一套适合小朋友的语言风格, 这就是格式化器
     

下面我们分别讲述四个模块:

#### `Logger`
- `Logger`的三大任务
    - 向应用程序代码暴露几个方法，使应用程序可以在运行时记录日志消息；
    - 基于日志严重等级（默认的过滤设施）或filter对象来决定要对哪些日志进行后续处理；
    - 将日志消息传送给所有感兴趣的日志handlers。
    
- 相关功能
    - 对日志进行配置
        - `Logger.setLevel()`: 	设置日志器将会处理的日志消息的最低严重级别
        - `Logger.addHandler()` 和 `Logger.removeHandler()`: 	为该logger对象添加 和 移除一个handler对象
        - `Logger.addFilter()` 和 `Logger.removeFilter()`: 	为该logger对象添加 和 移除一个filter对象
            
    - 创建日志
        - `Logger.debug()`: 创建调试信息
        - `Logger.exception()`: 创建类似于Logger.error的日志消息
        - `Logger.log()`:获取一个明确的日志level参数类创建一个日志记录

- 得到`Logger`对象的方法
    - 实例化
    - `logging.getLogger()`: 此时得到的日志名称为'root'
    
#### `Handler`
- 功能是把消息发送到`handler`指定的位置
- Logger通过addHandler添加handler
- 常用方法:
    - setLevel
    - setFormat
    - addFilter, removeFilter
  
- 不要直接使用,`Handler`是基础类, 常用的处理器有:
    - `logging.StreamHandler`: 	将日志消息发送到输出到`Stream`，如`std.out`, `std.err`或任何`file-like`对象。
    - `logging.FileHandler`: 	将日志消息发送到磁盘文件，默认情况下文件大小会无限增长
    - `logging.handlers.RotatingFileHandler`: 	将日志消息发送到磁盘文件，并支持日志文件按大小切割
    - `logging.hanlders.TimedRotatingFileHandler`: 	将日志消息发送到磁盘文件，并支持日志文件按时间切割
    - `logging.handlers.HTTPHandler`: 	将日志消息以GET或POST的方式发送给一个HTTP服务器
    - `logging.handlers.SMTPHandler`: 	将日志消息发送给一个指定的email地址
    - `logging.NullHandler`: 	该`Handler`实例会忽略`error messages`，通常被想使用`logging`的`library`开发者使用来避免'No handlers could be found for logger XXX'信息的出现。
#### `Filter`类
- 被`Handdler`和`Logger`使用
- 用于具体控制传递的`record`记录是否能通过过滤

#### `Formatter`类

- 控制输出格式, 三个参数:
    - fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值
    - datefmt：指定日期格式字符串，如果不指定该参数则默认使用"%Y-%m-%d %H:%M:%S"
    - style：Python 3.2新增的参数，可取值为 '%', '{'和 '$'，如果不指定该参数则默认使用'%'
    
```python

'''

1. 需求

现在有以下几个日志记录的需求：

    1）要求将所有级别的所有日志都写入磁盘文件中
    2）all.log文件中记录所有的日志信息，日志格式为：日期和时间 - 日志级别 - 日志信息
    3）error.log文件中单独记录error及以上级别的日志信息，日志格式为：日期和时间 - 日志级别 - 文件名[:行号] - 日志信息
    4）要求all.log在每天凌晨进行日志切割

2. 分析

    1）要记录所有级别的日志，因此日志器的有效level需要设置为最低级别--DEBUG;
    2）日志需要被发送到两个不同的目的地，因此需要为日志器设置两个handler；另外，两个目的地都是磁盘文件，因此这两个handler都是与FileHandler相关的；
    3）all.log要求按照时间进行日志切割，因此他需要用logging.handlers.TimedRotatingFileHandler; 而error.log没有要求日志切割，因此可以使用FileHandler;
    4）两个日志文件的格式不同，因此需要对这两个handler分别设置格式器；
'''

import logging
import logging.handlers
import datetime

logger = logging.getLogger('mylogger')
logger.setLevel(logging.DEBUG)

rf_handler = logging.handlers.TimedRotatingFileHandler('all.log', when='midnight', interval=1, backupCount=7, atTime=datetime.time(0, 0, 0, 0))
rf_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))

f_handler = logging.FileHandler('error.log')
f_handler.setLevel(logging.ERROR)
f_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s"))

logger.addHandler(rf_handler)
logger.addHandler(f_handler)

logger.debug('debug message')
logger.info('info message')
logger.warning('warning message')
logger.error('error message')
logger.critical('critical message')
```

## `loguru`

`loguru`是开发的方便使用的一个日志模块, 需要安装使用

`pip install loguru`

### 简单使用
简单实用基本可以开箱即用, 直接导入用就更好了, 参看下嘛代码:

```python
from loguru import logger

logger.debug("我是刘大拿")
logger.info("卫星号 131 191 44223")
logger.error("QQ群也不能忘了, 999 0960")
```

### 添加绑定

一个日志系统需要各种设置, 比如日志文件叫啥, 相关属性, 写满了如何处置, 记录
内容的格式等, `loguru`处理配置尽量简单,一个`add`函数满足绝大部分需要, 看下
函数的签名:

```python

def add(
        self,
        sink: Union[str, PathLike[str]],
        *,
        level: Union[str, int] = ...,
        format: Union[str, FormatFunction] = ...,
        filter: Optional[Union[str, FilterFunction, FilterDict]] = ...,
        colorize: Optional[bool] = ...,
        serialize: bool = ...,
        backtrace: bool = ...,
        diagnose: bool = ...,
        enqueue: bool = ...,
        catch: bool = ...,
        rotation: Optional[Union[str, int, time, timedelta, RotationFunction]] = ...,
        retention: Optional[Union[str, int, timedelta, RetentionFunction]] = ...,
        compression: Optional[Union[str, CompressionFunction]] = ...,
        delay: bool = ...,
        mode: str = ...,
        buffering: int = ...,
        encoding: str = ...,
        **kwargs: Any
) -> int: ...
```

我们对几个参数进行解释:


### 一个案例

```python
第一个参数是保存日志信息的文件路径，像我写的后缀多了个 {time} ，就是获取当前时间节点，这样就会自动创建新的日志；这个time应该是库里自带的变量，如果你想自己定义time也可以的哦，具体可以看看下面封装类的实现形式！

当你需要输出中文日志的时候，请加上 encoding=“utf-8” ，避免出现乱码

enqueue=True 代表异步写入，官方的大概意思是：在多进程同时往日志文件写日志的时候使用队列达到异步功效

rotation 可以理解成日志的创建时机，可以有多种写法 ◦rotation=“500 MB” ：当日志文件达到500MB时就会重新生成一个文件

rotation=“12:00” ：每天12点就会创建新的文件、

rotation=“1 week” ：每隔一周创建一个log

retention 配置日志的最长保留时间，官方例子： “1 week, 3 days”、“2 months”

compression 配置文件的压缩格式，可以配置常见的格式 zip、tar、gz、tar.gz 等
————————————————
版权声明：本文为CSDN博主「不像凡人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43681642/article/details/115377017``
