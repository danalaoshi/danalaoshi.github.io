---
layout: default
title: XML
parent: Python编程
nav_order: 26
---

- 参考
    - https://docs.python.org/3/library/xml.etree.elementtree.html
    - http://www.runoob.com/python/python-xml.html
    - https://blog.csdn.net/seetheworld518/article/details/49535285
    
- XML(eXtensible Markup Language), 可扩展标记语言
    - 标记语言： 语言中的都是用尖括号`<`和`>`括起来的文本字符串标记
    - 可扩展： 用户可以定义自己的需要的标记，
    - 例如:
        
            <Teacher> 
                自定义标记Teacher
                在两个标记之间任何内容都应该跟Teacher相关
            </Teacher>
    - XML是W3C组织指定的一个标准，是一种标准通用的描述数据语言
        - XML描述的是数据本身即数据的结构和语义，而不是格式化，
        - HTML主要描述的是如何显示web页面的数据(以后会讲)
- XML可以跨平台，跨应用程序工作
    - XML是W3C指定的标准，应用广泛
    - XML是一种标准通用的描述数据的语言
    - 主要用来在多个系统间公共数据的交换
    - XML是真正在的平台无关
    - 聚焦于数据的传输而不是显示
    - XML文档的构成
        - 处理指令(可以认为一个文件内只有一个处理指令)
        - 根元素(一个文件内只有一个根元素)
        - 子元素
        - 属性
        - 内容
        - 注释
- XML长这样： 
    - ![xml01.png](../pic/xml01.png)
- 规范的XML
    - 规范的XML文件是严格按照W3C标准产生的
    - XML处理器会按一定顺序读取内容，当发现语法错误的时候，会立即停止
    - 常见规则：
        - 名字中不能包含空格
        - 名字不能一数字或者标点符号开头
        - 左尖括号后不能出现空格
        - 起始和结束标签的大小写必须一直（大小写敏感)
        - XML文件中出现的第一个元素是根元素
        - 元素必须有完整的起始和结束标签
        - 所有元素必须嵌套在一个根元素内
        - 嵌套元素不可以相互重叠
        - 子元素如果内容为空可以缩写标签
        
                <Book ID>1</Book ID> #不对，名字中间不能有空格
                <1BookID>1</1BookID> #不能以数字开头
                < Name>WangDapang</Name> #左尖括号不能跟空格
                <name>Wang</Name> #大小写不一致
            
    - XML属性规则 
        - 属性可以在起始标签和处理指令之间声明
        - 可以有多个属性，但需要使用空格分隔
        - 每条属性包括属性名和属性值两部分
            1. 一个元素中不能有重名的属性
            2.不同元素中属性名可以重复
            3. 属性名不能包含空格
            4. 赋值可以使用单引号或者双引号
        - XML中选择属性还是元素
            - 元素用于封装数据，
            - 属性通常用于提供有关元素的伴随信息，而不是原始数据本身
            
                    <Book ID="1" ID="2">1</Book> #属性名重复
                    <Teacher First Name="Wang">WangDaPeng</Teacher>
                    #属性名中间不能有空格
        - XML处理指令
            - 与XML本身处理器相关的一些声明或者指令
                - 以xml关键字开头
                - 在xml文件中只能出现一次并且必须在头部
                - 一般用于声明XML的版本和采用的
                    - version属性是必须的
                    - encoding属性用来支出xml解释器使用的编码
        - 注释
            - 注释不能嵌套在标签里
            - 只有在注释的开始和结尾使用双短横线
            - 三短横线只能出现在注释的开头而不能公用在结尾
            
                    <name> <!-- wangdapeng -->   </name> #可以
                    <name <!-- wangdapeng -->>   </name> #不可以，注释在标签内
                    
                    <!--my-name-by-wang--> #可以，注释内容可以有一个短横线
                    <!--my--name--by--wang-->#不可以，双短横线只能出现在开头或结尾
                    
                    <!---my-name--> #可以， 三短横线只能出现在开头
                    <!---my-name---> #不可以， 三短横线只能出现在开头
            
        - 保留字符的处理
            - xml中使用的符号会和实际使用中的符号冲突，比如大于，小于号
            - 使用实体引用（EntityReferences）来表示保留字符
                
                    <score> score>80 </score> #有错误，xml中不能出现>
                    <score> score>80</score> #使用实体引用
            - 把含有保留字符的部分放在CDATA块内部，CDATA块只是XML编译器讲标记视为字符数据
            
                    <![CDATA[
                     select name,age
                     from Student
                     where score>80
                     ]]>
            - 常见的保留字符和对应的实体引用
                - &:&
                - <:<
                - >:>
                - ':'
                - ":"
                - 一共五个， 每个实体引用都以&开头并且以分号结尾
        - 标记的命名规则
            - 目的是使XML文件更容易读懂
            - 一般用首字母大写格式定义元素和属性
                - Pascal命名规则
            - 尽量避免缩写，缩写回让文件可读性降低 
            
                <Student>
                    <FirstName>wang</FirstName>
                    <LastName>DaPeng</LastName>
                </Student>      
                
        - 命名空间
            - 避免名称冲突
            - 是对元素名称的一种逻辑划分
                - XML命名空间用来限定XML文件中的元素和属性的名称，命名空间能够对元素分组
                - 使用命名空间可以有效防止在合并多个XML源文件时发生名称重名混淆
            
                    <Student>
                        <Name>WangPeng</Name>
                        <Age>23</Age>
                    </Student>
                    <Room>
                        <Name>2014</Name>
                        <Location>1-23-1</Location>
                    </Room>
                    
                    如果对上述两个元素合并，则会出现两个Name
                    <School>
                        <Name>WangPeng</Name>
                        <Age>23</Age>
                        <Name>2014</Name>
                        <Location>1-23-1</Location>
                    </School>
                    
                - 在合并上述文件中就会发现Name元素冲突
            - 显式命名空间讲每个URI和一个前缀关联
            - 使用前缀指定一个元素属于某个命名空间
            - 只有带这个前缀的元素和属性才属于这个特定的命名空间
            
                    <Student>
                        <Name>WangPeng</Name>
                        <Age>23</Age>
                    </Student>
                    <Room>
                        <Name>2014</Name>
                        <Location>1-23-1</Location>
                    </Room>
                    
                    如果对上述两个元素合并，则会出现两个Name
                    <School xmlns:teacher="http://taeweb"
                            xmlns:room="http:/room">
                        <teacher:Name>WangPeng</teacher:Name>
                        <Age>23</Age>
                        <room:Name>2014</room:Name>
                        <Location>1-23-1</Location>
                    </School>
  
- XML访问                  
    - SAX(Simple API for XML)
        - 基于事件驱动的API
        - 利用SAX解析XML文档牵涉解析器和事件处理器两部分
        - 事件处理器则负责读取相应XML数据的时候做出反应处理
        - 特点：
            - 快速
            - 流式读取
    - DOM
        - 是W3C规定的XML编程借口
        - 一整个XML文件在缓存中以一个树状结构保存，读取
        - 用途：
            - 定位和浏览XML中任一个节点
            - 添加删除相应内容
        - minidom
            - 参看下面 student.xml代码：
          
                    <?xml version="1.0" encoding="utf-8" ?>
                    <School>
                       <Teacher>
                           <Name>WangDaPeng</Name>
                           <Age detail="Age for year 2010">18</Age>
                           <Mobile>13260446055</Mobile>
                       </Teacher>
                        <Student>
                            <Name Other="他是班长">ZhangSan</Name>
                            <Age Detail="The yongest boy in class">14</Age>
                        </Student>
                        <Student>
                            <Name>LiSi</Name>
                            <Age>19</Age>
                            <Mobile>13240484187</Mobile>
                        </Student>
                       <!-- 这是一个例子而已 -->

                    </School>

            - 对上面student.xml 使用案例：
                
                   import xml.dom.minidom
                    # 负责解析xml文件
                    from xml.dom.minidom import parse

                    # 使用minidom打开xml文件
                    DOMTree = xml.dom.minidom.parse("student.xml")
                    #得到文档对象
                    doc = DOMTree.documentElement

                    # 显示子元素
                    for ele in doc.childNodes:
                        if ele.nodeName == "Teacher":
                            print("-------Node:{0}-----".format(ele.nodeName))
                            childs = ele.childNodes
                            for child in childs:
                                if child.nodeName == "Name":
                                    # data是文本节点的一个属性，表示他的值
                                    print("Name: {0}".format(child.childNodes[0].data))
                                if child.nodeName == "Mobile":
                                    # data是文本节点的一个属性，表示他的值
                                    print("Mobile: {0}".format(child.childNodes[0].data))
                                if child.nodeName == "Age":
                                    # data是文本节点的一个属性，表示他的值
                                    print("Age: {0}".format(child.childNodes[0].data))
                                    if child.hasAttribute("detail"):
                                        print("Age-detail: {0}".format(child.getAttribute("detail"))) 
             
            - minidom.parse(filename):加载读取的xml文件, filename也可以是xml代码
            - doc.documentElement:获取xml文档对象，一个xml文件只有一个对于的文档对象
            - node.getAttribute(attr_name):获取xml节点的属性值
            - node.getElementByTagName(tage_name)：得到一个节点对象集合
            - node.childNodes:得到所有孩子节点
            - node.childNodes[index].nodeValue:获取单个节点值
            - node.firstNode:得到第一个节点，等价于node.childNodes[0]
            - node.attributes[tage_name]
        - etree(ElementTree)
            - 以树形结构来表示xml
            - root.getiterator:得到相应的可迭代的node集合
            - root.iter
            - find(node_name):查找指定node_name的节点,返回一个node
            - root.findall(node_name):返回多个node_name的节点
            - node.tag: node对应的tagename
            - node.text:node的文本值
            - node.attrib： 是node的属性的字典类型的内容
            - 案例02
             
                
                import xml.etree.ElementTree

                root = xml.etree.ElementTree.parse("student.xml")
                print("利用getiterator访问：")
                nodes = root.getiterator()
                for node in nodes:
                    print("{0}--{1}".format(node.tag, node.text))

                print("利用find和findall方法：")
                ele_teacher = root.find("Teacher")
                print("{0}--{1}".format(ele_teacher.tag, ele_teacher.text))

                ele_stus = root.findall("Student")
                for ele in ele_stus:
                    print("{0}--{1}".format(ele.tag, ele.text))
                    for sub in ele.getiterator():
                        if sub.tag =="Name":
                            if "Other" in sub.attrib.keys():
                                print(sub.attrib['Other'])

- XML生成
    - 负责XML的修改，增加，创建
        - ele.set:修改属性
        - ele.append:增加子元素
        - ele.remove: 删除元素
    - 创建
    - 修改： 案例v03
  
            import xml.etree.ElementTree as et

            tree = et.parse(r'to_edit.xml')
            root = tree.getroot()
            for e in root.iter('Name'):
                print(e.text)

            for stu in root.iter('Student'):
                name = stu.find('Name')

                if name != None:
                    name.set( 'test', name.text * 2)

            stu = root.find('Student')

            e = et.Element('ADDer')
            e.attrib = {'a':'b'}
            e.text = '我加的'

            stu.append(e)
            tree.write('to_edit.xml')
     
    - 构建xml, SubElement(), 案例v04
    - minidom写入， 案例v05
  
            import xml.dom.minidom

            #在内存中创建一个空的文档
            doc = xml.dom.minidom.Document()
            #创建一个根节点Managers对象
            root = doc.createElement('Managers')
            #设置根节点的属性
            root.setAttribute('company', 'xx科技')
            root.setAttribute('address', '科技软件园')
            #将根节点添加到文档对象中
            doc.appendChild(root)

            managerList = [{'name' : 'joy',  'age' : 27, 'sex' : '女'},
                           {'name' : 'tom', 'age' : 30, 'sex' : '男'},
                           {'name' : 'ruby', 'age' : 29, 'sex' : '女'}
            ]

            for i in managerList :
              nodeManager = doc.createElement('Manager')
              nodeName = doc.createElement('name')
              #给叶子节点name设置一个文本节点，用于显示文本内容
              nodeName.appendChild(doc.createTextNode(str(i['name'])))

              nodeAge = doc.createElement("age")
              nodeAge.appendChild(doc.createTextNode(str(i["age"])))

              nodeSex = doc.createElement("sex")
              nodeSex.appendChild(doc.createTextNode(str(i["sex"])))

              #将各叶子节点添加到父节点Manager中，
              #最后将Manager添加到根节点Managers中
              nodeManager.appendChild(nodeName)
              nodeManager.appendChild(nodeAge)
              nodeManager.appendChild(nodeSex)
              root.appendChild(nodeManager)
            #开始写xml文档
            fp = open('Manager.xml', 'w')
            doc.writexml(fp, indent='\t', addindent='\t', newl='\n', encoding="utf-8")
     
    - etree创建xml， 案例v06

            import xml.etree.ElementTree as et

            #在内存中创建一个空的文档
            etree = et.ElementTree()
            e = et.Element('Student')
            etree._setroot(e)
            e_name = et.SubElement(e, 'Name')
            e_name.text = "hahahah"

            etree.write('v06.xml')


